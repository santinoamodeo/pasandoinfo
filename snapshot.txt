#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import os, time, pickle, sys
from dotenv import load_dotenv
from PIL import Image

from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.common.exceptions import TimeoutException

# Chromium (APT)
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.chrome.service import Service

# =======================
# Cargar variables .env
# =======================
ENV_PATH = os.path.join(os.path.dirname(__file__), "..", ".env")
if not load_dotenv(ENV_PATH):
    print("Aviso: no se pudo cargar .env; usaré variables de entorno si existen.", file=sys.stderr)

USER = os.getenv("GROWATT_USER", "")
PASS = os.getenv("GROWATT_PASS", "")
DASHBOARD_URL = os.getenv("DASHBOARD_URL", "https://server.growatt.com/index")
SEL = (os.getenv("DASHBOARD_SELECTOR") or "").strip()   # vacío => full page
OUT = os.getenv("OUTPUT_PATH", "/var/www/growatt/latest.png")
VW = int(os.getenv("VIEWPORT_W", "1920"))
VH = int(os.getenv("VIEWPORT_H", "1080"))
EXTRA_WAIT = int(os.getenv("EXTRA_WAIT", "8"))

COOKIES_PATH = os.path.join(os.path.dirname(__file__), "cookies.pkl")

# =======================
# Driver Chromium (APT)
# =======================
def build_driver():
    """
    Usa el binario de Chromium y ChromeDriver instalados por APT:
      - /usr/bin/chromium-browser
      - /usr/lib/chromium-browser/chromedriver
    Si tus rutas difieren, cámbialas aquí.
    """
    opts = Options()
    opts.binary_location = "/usr/bin/chromium-browser"     # binario APT, NO el snap
    opts.add_argument("--headless")
    opts.add_argument("--no-sandbox")
    opts.add_argument("--disable-dev-shm-usage")
    opts.add_argument(f"--window-size={VW},{VH}")
    service = Service("/usr/lib/chromium-browser/chromedriver")
    return webdriver.Chrome(service=service, options=opts)

# =======================
# Utilidades de cookies/FS
# =======================
def ensure_dir(file_path: str):
    os.makedirs(os.path.dirname(file_path), exist_ok=True)

def load_cookies(driver, url_base="https://server.growatt.com/"):
    if os.path.exists(COOKIES_PATH):
        driver.get(url_base)
        try:
            with open(COOKIES_PATH, "rb") as f:
                cookies = pickle.load(f)
            for c in cookies:
                c.pop("sameSite", None)  # evita errores en algunas versiones
                try:
                    driver.add_cookie(c)
                except Exception:
                    pass
        except Exception:
            pass

def save_cookies(driver):
    try:
        with open(COOKIES_PATH, "wb") as f:
            pickle.dump(driver.get_cookies(), f)
    except Exception:
        pass

# =======================
# Detección/login
# =======================
def is_login_page(driver):
    # Detecta login por IDs reales del formulario
    try:
        driver.find_element(By.CSS_SELECTOR, "#val_loginAccount")
        driver.find_element(By.CSS_SELECTOR, "#val_loginPwd")
        return True
    except Exception:
        return "login" in (driver.current_url or "").lower()

def do_login(driver):
    # Ir directo a /login
    driver.get("https://server.growatt.com/login")
    wait = WebDriverWait(driver, 30)

    # Campos reales
    user = wait.until(EC.presence_of_element_located((By.CSS_SELECTOR, "#val_loginAccount")))
    pwd  = wait.until(EC.presence_of_element_located((By.CSS_SELECTOR, "#val_loginPwd")))

    user.clear(); user.send_keys(USER)
    pwd.clear();  pwd.send_keys(PASS)

    # Click al botón "Login" (clases observadas: hasColorBtn loginB)
    try:
        btn = wait.until(EC.element_to_be_clickable(
            (By.CSS_SELECTOR, "button.hasColorBtn.loginB, .loginBtn button.hasColorBtn.loginB")
        ))
        btn.click()
    except Exception:
        # fallback: ENTER
        pwd.send_keys(Keys.ENTER)

    # Esperar a que deje /login
    wait.until(lambda d: "/login" not in (d.current_url or ""))

    # Si no nos dejó en /index, forzar
    if "/index" not in (driver.current_url or ""):
        driver.get(DASHBOARD_URL)

    save_cookies(driver)

# =======================
# Esperas robustas de SPA
# =======================
def wait_dom_ready(driver, timeout=30):
    WebDriverWait(driver, timeout).until(
        lambda d: d.execute_script("return document.readyState") == "complete"
    )

def click_dashboard_tab(driver):
    """
    Click en el tile/botón Dashboard si existe.
    """
    candidates = [
        (By.XPATH, "//*[normalize-space(text())='Dashboard']"),
        (By.CSS_SELECTOR, ".dashboard, .menu-dashboard, .home-dashboard")
    ]
    for by, sel in candidates:
        try:
            el = WebDriverWait(driver, 5).until(EC.element_to_be_clickable((by, sel)))
            el.click()
            time.sleep(0.5)
            return True
        except Exception:
            continue
    return False

def wait_loader_gone_js(driver, timeout=60):
    """
    Espera a que no haya overlays/spinners visibles (via JS).
    Retorna True si el loader desaparece antes del timeout.
    """
    end = time.time() + timeout
    js = """
      const sel = ['.el-loading-mask','.el-loading-spinner','.layui-layer-loading','.loading','.is-loading'];
      function anyVisible() {
        for (const s of sel) {
          const el = document.querySelector(s);
          if (!el) continue;
          const style = window.getComputedStyle(el);
          const rect = el.getBoundingClientRect();
          const visible = style.visibility !== 'hidden' &&
                          style.display !== 'none' &&
                          rect.width > 1 && rect.height > 1 && rect.bottom > 0 && rect.right > 0;
          if (visible) return true;
        }
        const txt = document.body.innerText || '';
        if (txt.includes('Loading')) return true;
        return false;
      }
      return anyVisible();
    """
    while time.time() < end:
        try:
            if not driver.execute_script(js):
                return True
        except Exception:
            pass
        time.sleep(1.0)
    return False

def wait_dashboard_ready(driver, hard_timeout=60, extra_wait=5):
    """DOM listo → (opcional) click Dashboard → esperar loaders → refresco de rescate → espera extra."""
    wait_dom_ready(driver, timeout=min(30, hard_timeout))
    click_dashboard_tab(driver)  # no pasa nada si no encuentra

    ok = wait_loader_gone_js(driver, timeout=hard_timeout)
    if not ok:
        # Refresco de rescate una vez
        driver.execute_script("location.reload()")
        wait_dom_ready(driver, timeout=min(30, hard_timeout))
        click_dashboard_tab(driver)
        wait_loader_gone_js(driver, timeout=hard_timeout)

    if extra_wait > 0:
        time.sleep(extra_wait)

# =======================
# Screenshots
# =======================
def fullpage_screenshot(driver, out_path):
    # Captura “full page” (con stitching si hace falta)
    total_h = driver.execute_script(
        "return Math.max(document.body.scrollHeight, document.documentElement.scrollHeight)"
    )
    if total_h <= VH:
        driver.save_screenshot(out_path)
        return

    stitched = Image.new("RGB", (VW, total_h), (255, 255, 255))
    y = 0
    for offset in range(0, total_h, VH):
        driver.execute_script(f"window.scrollTo(0, {offset});")
        time.sleep(0.3)
        tmp = out_path + ".part.png"
        driver.save_screenshot(tmp)
        img = Image.open(tmp)
        crop_h = min(VH, total_h - offset)
        stitched.paste(img.crop((0, VH - crop_h, VW, VH)), (0, y))
        y += crop_h
        img.close()
        os.remove(tmp)
    stitched.save(out_path)

def element_screenshot(driver, selector, out_path):
    WebDriverWait(driver, 20).until(EC.presence_of_element_located((By.CSS_SELECTOR, selector)))
    el = driver.find_element(By.CSS_SELECTOR, selector)
    el.screenshot(out_path)

# =======================
# Main
# =======================
def main():
    if not USER or not PASS:
        print("[ERR] Falta GROWATT_USER o GROWATT_PASS en .env/entorno", file=sys.stderr)
        sys.exit(1)

    ensure_dir(OUT)

    driver = build_driver()
    try:
        # Intentar con cookies primero; si redirige a login, hacemos login
        driver.get(DASHBOARD_URL)
        load_cookies(driver)
        time.sleep(1.0)

        if is_login_page(driver):
            do_login(driver)

        # Esperar dashboard listo (con refresh de rescate y extra wait)
        wait_dashboard_ready(driver, hard_timeout=60, extra_wait=EXTRA_WAIT)

        # Screenshot (full page o por selector)
        if SEL:
            element_screenshot(driver, SEL, OUT)
        else:
            fullpage_screenshot(driver, OUT)

        print(f"[OK] Snapshot guardado en: {OUT}")
    except Exception as e:
        print("[ERR] Message:", e, file=sys.stderr)
    finally:
        try:
            driver.quit()
        except Exception:
            pass

if __name__ == "__main__":
    main()
